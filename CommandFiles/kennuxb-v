// @ts-check
import axios from "axios";

/**
 * @type {CassidySpectra.CommandMeta}
 */
export const meta = {
  name: "tempmail",
  author: "Hazeey | AkhiroDEV",
  description: "Generate a tempmail",
  usage: "tempmail gen",
  version: "1.0.1",
  params: [["gen", "inbox"]],
  shopPrice: 100,
  requirement: "3.0.0",
  icon: "📩",
  category: "Utilities",
};

/**
 *
 * @param {CommandContext} param0
 */
export async function entry({ api, event }) {
  const args = event.body.split(/\s+/);
  args.shift();

  if (args[0] === "gen") {
    try {
      const response = await axios.get(
        "https://haze-temp-getter-e8bcc9ade589.herokuapp.com/get"
      );
      const responseData = response.data;

      if (Array.isArray(responseData)) {
        let emails = responseData.map((obj) => "➤ " + obj.email).join("\n\n");
        api.sendMessage(
          `📩 𝐓𝐞𝐦𝐩𝐌𝐚𝐢𝐥\n\n✄┈┈┈┈┈┈┈┈┈┈┈┈┈┈\n\n✉️ 𝙴𝚖𝚊𝚒𝚕𝚜:\n\n${emails}\n\n✄┈┈┈┈┈┈┈┈┈┈┈┈┈┈`,
          event.threadID,
          event.messageID
        );
      } else {
        api.sendMessage(
          "🚫 𝙸𝚗𝚟𝚊𝚕𝚒𝚍 𝚁𝚎𝚜𝚙𝚘𝚗𝚜𝚎 𝚏𝚘𝚛𝚖𝚊𝚝",
          event.threadID,
          event.messageID
        );
      }
    } catch (error) {
      console.error("🚫 𝙴𝚛𝚛𝚘𝚛", error);
      api.sendMessage(
        "🚫 𝙴𝚛𝚛𝚘𝚛 𝚘𝚌𝚌𝚞𝚛𝚎𝚍 𝚠𝚑𝚒𝚕𝚎 𝚏𝚎𝚝𝚌𝚑𝚒𝚗𝚐 𝚎𝚖𝚊𝚒𝚕𝚜.",
        event.threadID,
        event.messageID
      );
    }
  } else if (args[0]?.toLowerCase() === "inbox" && args.length === 2) {
    const email = args[1];
    try {
      const response = await axios.get(
        `https://haze-temp-getter-e8bcc9ade589.herokuapp.com/get/${email}`
      );
      const inboxMessages = response.data;
      let formattedMessages = inboxMessages
        .map(
          (message) =>
            `👤 𝙵𝚛𝚘𝚖: ${message.from}\n📬 𝚂𝚞𝚋𝚓𝚎𝚌𝚝: ${message.subject}\n\n✄┈┈┈┈┈┈┈┈┈┈┈┈┈┈\n\n💌 𝙼𝚊𝚒𝚕:\n\n${message.body}\n✄┈┈┈┈┈┈┈┈┈┈┈┈┈┈\n\n𝙳𝚊𝚝𝚎: ${message.date}`
        )
        .join("\n\n");
      api.sendMessage(
        `📩 𝐈𝐧𝐛𝐨𝐱 𝐌𝐞𝐬𝐬𝐚𝐠𝐞𝐬 \n\n${formattedMessages}`,
        event.threadID,
        event.messageID
      );
    } catch (error) {
      console.error("🚫 𝙴𝚛𝚛𝚘𝚛", error);
      api.sendMessage("🚫 𝙰𝚗 𝚎𝚛𝚛𝚘𝚛 𝚘𝚌𝚌𝚞𝚛𝚎𝚍.", event.threadID, event.messageID);
    }
  } else {
  }
}
@ts-check

/**
 * @type {CassidySpectra.CommandMeta}
 */
export const meta = {
  name: "fbcover",
  description: "Create a Facebook Cover Photo.",
  author: "Deku",
  version: "1.0.0",
  usage: "{prefix}fbcover <name> | <number> | <address> | <email> | <color>",
  category: "Media",
  permissions: [0],
  noPrefix: false,
  botAdmin: false,
  waitingTime: 1,
  requirement: "3.0.0",
  icon: "📷",
  deku: true,
};

export const style = {
  title: "📷 FB Cover",
  titleFont: "bold",
  contentFont: "fancy",
};

import { DekuAlt } from "@cass-modules/deku-api";

/**
 * @param {CassidySpectra.CommandContext} ctx
 */
export async function entry({
  event,
  input,
  output,
  args,
  money,
  threadsDB,
  prefix,
}) {
  const opts = input.splitArgs("|");
  const [name, number, address, email, color] = opts;

  if (opts.length < 5) {
    return output.reply(
      `❌ ***Incorrect Syntax***\n\n**Guide:** ${meta.usage}`.replaceAll(
        "{prefix}",
        prefix
      )
    );
  }

  const i = await output.reply("⏳ ***Generating***\n\nPlease wait...");

  const [nameA, ...nameB] = name.split(" ");
  const nameBStr = nameB.join(" ");

  const params = {
    name: nameA,
    subname: nameBStr,
    sdt: number,
    address,
    email: email,
    uid: event.originalEvent?.senderID ?? input.sid,
    color,
  };

  const { data: image } = await DekuAlt.get("/canvas/fbcover", {
    params,
    responseType: "stream",
  });

  await output.reply({
    body: `✅ ***Cover Generated***\n\n${Object.entries(params)
      .map((i) => `**${i[0].toTitleCase()}**: ${i[1]}`)
      .join("\n")}`,
    attachment: image,
  });

  await output.unsend(i.messageID);
}
// @ts-check
/**
 * @type {CassidySpectra.CommandMeta}
 */
export const meta = {
  name: "uptime",
  description: "Check Uptime Status.",
  otherNames: ["upt", "up"],
  version: "1.0.0",
  author: "Liane Cagara",
  usage: "{prefix}{name}",
  category: "System",
  permissions: [0],
  noPrefix: "both",
  waitingTime: 5,
  requirement: "3.0.0",
  icon: "🌏",
};
import os from "os";

export const style = {
  title: "Uptime 🌏",
  titleFont: "bold",
  contentFont: "fancy",
};

const { formatTimeDiff, formatBits } = global.utils;

/**
 *
 * @param {CommandContext} param0
 */
export async function entry({ output }) {
  /**
   * @param {number} value
   * @param {string} unit
   */
  function formatTimeUnit(value, unit) {
    return value ? `${value} ${unit}${value > 1 ? "s" : ""}, ` : "";
  }

  const { uptime } = global.Cassidy;
  const { years, months, days, hours, minutes, seconds } =
    formatTimeDiff(uptime);

  const uptimeString = `The bot is running for ${formatTimeUnit(
    years,
    "year"
  )}${formatTimeUnit(months, "month")}${formatTimeUnit(
    days,
    "day"
  )}${formatTimeUnit(hours, "hour")}${formatTimeUnit(
    minutes,
    "minute"
  )}and ${seconds} second${seconds > 1 ? "s" : ""}.`;
  const osInfo = {
    platform: os.platform(), // this is the operating system platform (e.g., "win32", "linux", "darwin")
    type: os.type(), // the operating system name (e.g., "Windows_NT", "Linux", "Darwin")
    release: os.release(), // operating system release version (e.g., "10.0.19041", "4.19.0-16-amd64")
    uptime: os.uptime(), // The system uptime in seconds, is this different than process.uptime!?
    hostname: os.hostname(), // obviously, the hostname of the operating system
    arch: os.arch(), // The CPU architecture (e.g., "x64", "arm", "ia32") as defined by gogol
    totalMemory: formatBits(os.totalmem()), // Total system memory in bytes
    freeMemory: formatBits(os.freemem()), // Free system memory in bytes
    cpus: os.cpus().length, // Number of CPU cores..
    usedMemory: formatBits(os.totalmem() - os.freemem()), // I realized I need this too.
  };
  // os.uptime is a better choice than process.uptime if your bost restarts mostly lmao
  const resultText = `**Platform**: ${osInfo.platform}
**Type**: ${osInfo.type}
**Release**: ${osInfo.release}
**Hostname**: ${osInfo.hostname}
**Architecture**: ${osInfo.arch}
**Memory**: ${osInfo.usedMemory}/${osInfo.totalMemory} (Free: ${osInfo.freeMemory})
**CPU Cores**: ${osInfo.cpus}
**Uptime**: ${uptimeString}`;
  output.reply(resultText);
}
/ @ts-check
import { ReduxCMDHome } from "@cassidy/redux-home";
import { UNISpectra } from "@cassidy/unispectra";

export const meta = {
  name: "admin",
  author: "Liane Cagara 🎀",
  noPrefix: false,
  version: "1.0.4",
  description: "Manage admins.",
  usage: "admin[prop] [command]",
  permissions: [0, 1, 2],
  requirement: "3.0.0",
  icon: "",
  category: "User Management",
};
const { Cassidy } = global;
export const style = {
  title: "Admins 👑",
  titleFont: "bold",
  contentFont: "fancy",
};

/**
 * @type {Record<string, CommandEntry>}
 */
export const entryConfig = {
  async addmod({ input, output, args, money }) {
    const { MODERATORBOT, ADMINBOT } = Cassidy.config;
    if (!input.isAdmin) {
      return output.reply(`❌ | You cannot add moderators.`);
    }
    const ID = input.detectID || args[0];
    if (!ID) {
      return output.reply(
        "❌ | Please specify the ID to add. Either reply/mention or add the ID to args[0]."
      );
    }
    const { name } = await money.getItem(ID);
    if (MODERATORBOT.includes(ID)) {
      return output.reply(`❌ | ${name} (${ID}) is already a moderator.`);
    }
    if (ADMINBOT.includes(ID)) {
      return output.reply(`❌ | ${name} (${ID}) is an admin.`);
    }

    MODERATORBOT.push(ID);
    Cassidy.config.MODERATORBOT = MODERATORBOT;
    return output.reply(`✅ | ${name} (${ID}) is now a moderator.`);
  },
  async removemod({ input, output, args, money }) {
    const { MODERATORBOT } = Cassidy.config;
    if (!input.isAdmin) {
      return output.reply(`❌ | You cannot remove moderators.`);
    }
    const ID = input.detectID || args[0];
    if (!ID) {
      return output.reply(
        "❌ | Please specify the ID to remove. Either reply/mention or add the ID to args[0]."
      );
    }
    if (ID.startsWith("web:") || ID.startsWith("wss:main")) {
      return output.reply(`❌ | Web users and wss main cannot be moderator!`);
    }

    const { name } = await money.getItem(ID);
    if (!MODERATORBOT.includes(ID)) {
      return output.reply(`❌ | ${name} (${ID}) is not a moderator.`);
    }
    Cassidy.config.MODERATORBOT = MODERATORBOT.filter((item) => item !== ID);
    return output.reply(`✅ | ${name} (${ID}) no longer a moderator.`);
  },

  async add({ input, output, args, money }) {
    const { ADMINBOT } = Cassidy.config;
    if (!input.isAdmin) {
      return output.reply(`❌ | You cannot add admins.`);
    }
    const ID = input.detectID || args[0];
    if (!ID) {
      return output.reply(
        "❌ | Please specify the ID to add. Either reply/mention or add the ID to args[0]."
      );
    }
    if (ID.startsWith("web:") || ID.startsWith("wss:main")) {
      return output.reply(`❌ | Web users and wss main cannot be admin!`);
    }
    const { name } = await money.getItem(ID);
    if (ADMINBOT.includes(ID)) {
      return output.reply(`❌ | ${name} (${ID}) is already an admin.`);
    }
    ADMINBOT.push(ID);
    Cassidy.config.ADMINBOT = ADMINBOT;
    return output.reply(`✅ | ${name} (${ID}) is now an admin.`);
  },
  async remove({ input, output, args, money }) {
    const { ADMINBOT } = Cassidy.config;
    if (!input.isAdmin) {
      return output.reply(`❌ | You cannot remove admins.`);
    }
    const ID = input.detectID || args[0];
    if (!ID) {
      return output.reply(
        "❌ | Please specify the ID to remove. Either reply/mention or add the ID to args[0]."
      );
    }
    const { name } = await money.getItem(ID);
    if (!ADMINBOT.includes(ID)) {
      return output.reply(`❌ | ${name} (${ID}) is not an admin.`);
    }
    Cassidy.config.ADMINBOT = ADMINBOT.filter((item) => item !== ID);
    return output.reply(`✅ | ${name} (${ID}) no longer an admin.`);
  },
  async list({ output, money }) {
    const { ADMINBOT = [], MODERATORBOT = [] } = Cassidy.config;
    const concat = [...MODERATORBOT, ...ADMINBOT];
    let result = `Total of ${concat.length} admins and moderators:\n\n`;
    let n = 1;
    result += `${UNISpectra.arrow} 👑 ***Admins***:\n`;
    const admins = await money.getItems(...ADMINBOT);
    const mods = await money.getItems(...MODERATORBOT);

    for (const [admin, { name }] of Object.entries(admins)) {
      result += `${n}. **${name}** (${admin})\n`;
      n++;
    }
    result += `\n${UNISpectra.arrow} 🛡️ ***Moderators***:\n`;
    for (const [moderator, { name }] of Object.entries(mods)) {
      result += `${n}. **${name}** (${moderator})\n`;
      n++;
    }
    return output.reply(result);
  },
};

const home = new ReduxCMDHome({
  entryConfig,
  entryInfo: {
    list: {
      description: "Display the list of admins",
    },
    addmod: {
      description: "Grant moderator privileges",
      args: ["<uid>"],
    },
    removemod: {
      description: "Revoke moderator privileges",
      args: ["<uid>"],
    },
    add: {
      description: "Add a new admin",
      args: ["<uid>"],
    },
    remove: {
      description: "Remove an existing admin",
      args: ["<uid>"],
    },
  },
});

export async function entry(ctx) {
  return home.runInContext(ctx);
}
